---
title: "The Data"
author: "Raven McKnight"
date: "9/28/2019"
output: html_document
---

# The Data 
```{r include=FALSE}
packages <- c('data.table', 'DT', 'knitr')

miss_pkgs <- packages[!packages %in% installed.packages()[,1]]

if(length(miss_pkgs) > 0){
  install.packages(miss_pkgs)
}

invisible(lapply(packages, library, character.only = TRUE))

rm(miss_pkgs, packages)
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'DT', 'data.table', 'splitstackshape'
), 'packages.bib')

apc <- readRDS('/Users/raven/Documents/honors/honors-work/data/mt-data/apc-sample.RDS')
setDT(apc)
## ADD THIS TO OUTPUTTING SCRIPT AT WORK
apc <- apc[!is.na(board) & !is.na(alight)]
trips <- readRDS('/Users/raven/Documents/honors/honors-work/data/mt-data/trips.RDS')
apcs <- readRDS('/Users/raven/Documents/honors/honors-work/data/mt-data/apc-sample.RDS')
apcag <- readRDS('/Users/raven/Documents/honors/honors-work/data/mt-data/apc-aggregate.RDS')
```
## Metro Transit Data


The ridership variable for this anlysis comes from [Metro Transit's](https://www.metrotransit.org/home) schedule, Automatic Passenger Count (APC), and Automatic Vehicle Location (AVL) data. APC and AVL data are counted by sensors on active vehicles. 

### Cleaning

Data was pulled from Metro Transit databases for trips ocurring between January 1, 2015 and December 31, 2018. The APC data consists of records of boarding and alighting each time a bus makes a stop and opens its doors. Boardings and alightings are counted by a beam of light across the doorway being broken when riders enter or exit. The APC data for 2015-2018 consists of approximately 492 billion rows. A single observation in the APC data looks like this: 

```{r include = FALSE}
# include appendix of data dictionary/transit terminology
```


```{r echo = FALSE}
kable(head(apcs, 1))
```

This data is sparse, with many boardings and alightings of 0. 

Automatically collected data is inherently faulty, so there is no guarantee that the APC records contain *all* trips run. To confirm we have all (most) run trips, we pull AVL data. The AVL data is generated by buses reporting their geolocation every 8 seconds while in service. We can use this data to find all *observed* trips from 2015 to 2018. A single observation of AVL data looks like this: 

```{r echo = FALSE}
# switch to kable
kable(head(trips, 1))
```


To locate trips missing APC records, we simply find trips in the AVL dataset with no corresponding APC record. Such records comprise about 1% (**check at work**) of all APC records. This is a small proportion of trips, but we expect that many "missing data" trips may occur on "unusual" routes -- those that are served by older buses or those which occur less frequently or further outside of the urban core (ie, express routes). As there are few such "unusual" routes to begin with, we want to make sure we're not underrepresenting them by dropping trips with no boarding and alighting. 

```{r include = FALSE}
#get numbers from work
```

We can use the Metro Transit schedule to interpolate appropriate boarding and alighting values for trips missing APC data. For each trip missing an APC record, we randomly sample the boarding and alighting from a different APC record occuring on the same route, in the same direction, at the same stop, with the same type of service, during the same pick (time period). Approximately 50% of missing APC records can be interpolated in this manner. The remaining 50% are dropped because they are not representative of Metro Transit's service. Trips with no matching trips were likely unscheduled, or were recorded in the AVL data by accident (sometimes buses have their AVL turned on when they are moving from garage to garage, or while they sit still all night). 

The three data sources described above are combined to create a single table with the following columns. 
```{r echo = FALSE}
dictionary <- data.table(names(apc))
dictionary$meaning <- c('date of observation', 'route', 'direction (ie northbound/southbound)', 'type of service (ie weekday/weekend)', 'bus stop id', 'number of boardings', 'number of alightings', 'indicates if board and alight were interpolated')

colnames(dictionary) <- c('variable', 'meaning')

kable(dictionary)
```

### Aggregation

Working with 492 billion rows of data is unrealistic. There are a few options for creating a more workable dataset. I opted to aggregate the data over each day. This reduces the data to approximately 23 million rows and ensures that no "edge cases" (such as express routes that only run a few times each week) are dropped as they might be in sampling. This does limit the temporal granularity of the analysis -- we can no longer model differences between rush hour and non-rush hour, for example. Such granularity is crucial to transportation planning but generally occurs in the final stages of route planning. For this purpose, variation by day, route, and stop is sufficiently granular. 

The other option is to take a stratified sample, where each strata is a day, route, direction, and stop (ie, all northbound A line stops at Snelling and Grand which occur today). A 10-20% sample taken in this way is fairly representative but can still drop sufficiently small groups. 

Here is a sample of the temporally aggregated data: 
```{r echo = FALSE}
datatable(head(apcag, 100))
```


### Spatial Aggregation

In addition to temporal aggregation, some spatial aggregation is necessary in order to fit meaningful models. While analyis at the stop level is important, it is difficult to assign covariates to isolated stops. For example, what is the population *at* a bus stop? I have (tentatively?) chosen to aggregate the bus stops to Census Block level. These areal units are small enough to maintain specificity across the metro area. Margins of error in Census data may be too large at the census block level. 



## Covariates